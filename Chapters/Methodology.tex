\chapter{Methodology}


%TODO: Write a proper motivation for why use cases and features are equivalent. 

In this chapter we explain the how we combine Model-Driven Engineering (MDE) technique with Product Line Engineering (PLE) techniques to identify features and requirements. This is then followed by establishing the relationship between features and requirements into a hierarchy to facilitate a well defined Feature-Driven Development (FDD) practice. Parts of this methodology were inspired by significant overlap between these seemingly very different domains of engineering practice. In the world of \ac{MDE}, \acfp{UCD} are often used to capture high-level knowledge for how stakeholders will interact with certain parts of a system. While the modelling approach is relatively informal in its semantics and syntax~\cite{fowler2018uml, lamsweerde2009requirements}, it has been claimed to support both technical and non-technical users alike in describing how they want stakeholders and customers to interact with their products or system.

%it does a good enough job of allowing technical and non-technical people alike to describe how they want stakeholders and customers to use their products.
%A main pillar of contribution for this thesis is recognizing overlaps between several very different domains.

\begin{figure}
	\centering
	\includegraphics[scale=0.5]{goals_n_system.png}
	\caption{List of steps from the Meyers Handbook for requirement engineering.}
	\label{fig:goals_n_system}
\end{figure}

The overall methodology for this thesis is heavily inspired by the Goals and System books from Meyer's requirement engineering book~\cite{meyer2022handbook}. The Goals book is primarily focused on capturing conceptual models of the stakeholders of the desired product and the purpose of building it. The System book is essentially a refinement of the concepts captured in the Goals book to actionable requirements ready for design and development. It dives into more of the details of stakeholder interaction, seeking to answer how to use a product while the Goals book seeks to answer question more focused on why the product should exist and what it will do for the stakeholders. We do not completely implement everything outlined in those books and instead have adapted them to suit our purposed. The steps of our proposed methodology are as follows:
\begin{enumerate}
	\item Identify stakeholders, users, and customers. Who will be impacted by the product?
	\item Identify stakeholder, user, and customer goals. Why would they need the product we are developing? Why would they not need the product in question?
	\item Identify stakeholder, user, and customer use cases for a designated system. Each use case should work to satisfy at least one goal. What will the product do to help the users and stakeholders?
	\item Identify system features based on use cases. These are the high-level features for our system. This is where the overlap between features and use cases can be leveraged to equate use cases from \ac{UML} to features in \ac{PLE}
	\item Refine use cases to user stories. These become our feature requirements.
	\item Support stories with identified stakeholder goals. We want to validate our requirements against the goals and use cases previously defined.
	\item Build high-level features into feature model. The feature model is where we being to capture the product family
	\item Decompose features as needed in feature model. Iteration possibilities between UCD and feature model here. At this point we can begin to identify variant requirements and features. We anticipate that this step will likely lead to increased insight into the product leading to potential decision changes that will create opportunity for iteration between the \ac{UCD} and feature modelling.
	\item Use features to encapsulate requirements.
	\item Model requirements from user stories in requirement canvas.
	\item Use behavioural specification for requirements within modelling environment.
	\item Generate bi-directional traceability between features and requirements.
\end{enumerate}

In the world of \ac{PLE}, a critical process is the identification of relevant system features. In the original work introducing the concept of Feature-Oriented Domain Analysis (FODA) Kyo Huang et al. defined a feature as ``A prominent or distinctive user-visible aspect, quality, or characteristic of a software system or systems"~\cite{kang1990feature}. While this definition has evolved beyond its original scope, the spirit of what a feature is has remained largely the same; an identifiable aspect or artifact of a system that is interacted with. For software, this can be as small as a variable assignment or entire modules and components. In a hardware system, a feature could be the different materials and components used to build a base model versus and top model trim, from the smallest screws to completely different chasis materials.

Finally, in \ac{FDD} the concept of a feature is also heavily used as a means of organization and task setting~\cite{palmer2001practical}. Features in this domain can often be client-focused tasks or actions that the software can perform. The features are used to scope the various tasks required to complete development of a product. 

Thus, the overlap becomes apparent; use cases from \ac{MDE}, features from \ac{PLE}, and features from \ac{FDD} all have some forms of overlap. They all have an emphasis on user or stakeholder interactions. They all attempt to capture domain knowledge of what the interactions are. Therefore, for this methodology we use these overlaps to develop strategies for feature/use case identification, requirement elicitation, and traceability. We also establish an pseudo-equivalency between features and use cases between \ac{PLE} and \ac{MDE} respectively.

To demonstrate the process, we focus our attention on the automotive domain as it is both safety-critical and complex with many product variants. It is a domain that combines both software and hardware. There are interactions both at the stakeholder level and internal to the vehicles. The combination of these factors means there is plenty of opportunity for requirement variants to emerge. This presents many challenges with project planning for vehicle development, designing hardware and software for a variety of vehicles, and maintaining documentation throughout the product lifecycle. The objective of this methodology is to capture variability earlier in development in a way that allows for actionable planning. By capturing variability in the requirements, engineers can more easily anticipate and plan around how to build modular systems from the start of a project.

Some examples of variability in the automotive domain can be how to adapt an engine to work in various drive train configurations (4x4, AWD, FWD, RWD) or an HVAC system working in a 1-row, 2-row, or 3-row vehicle. Further, it is a domain that already implements various versions of \ac{MDE}, \ac{PLE}, and \ac{FDD}. The examples shown are not complete and are focused on explaining the process involved for development. 

Another contribution of this methodology is in the level of abstraction for development. FeatureIDE~\cite{thum2014featureide} is mainly used for reusing software implementations. GEAR~\cite{GEARS} is spread out across adaptable ways for a company to be introduced to \ac{PLE} for design variants. However for industries that continue to grow in complexity capturing variants even earlier in the development phase, such as requirements, becomes increasingly necessary to handle complexity. We aim to introduce \ac{PLE} techniques earlier into the development process to capture complexity and variations at the requirement level to reduce uncertainty later in the development process.

In summary, once the stakeholders are identified, we want to capture what their goals are when interacting with our system. Those goals are used to guide and justify use cases. They are also used to reason about and refine requirements. By equating features and use cases, we take the use cases to begin feature modelling efforts and feature decomposition. Finally, we specify the requirements within each of the features. Naturally there is opportunity for incremental development within each stage and iterative development between them. We anticipate that most incremental and iterative development will occur between feature decomposition and use cases, between requirement specification and user stories, and feature decomposition and requirement specification. This is due to previous experiences working with industry partners to explore how to handle product variance and decomposition. We observed significant iteration at this level as project planning changes occurred due to changing environmental factors (changes in regulation, economic incentives etc.) and due to engineers learning more about the product they are developing and refining their requirements and designs over time.

\section{Domain Analysis}

Before any engineering work can take place, we must answer the question of who we are building this system for. Without knowing who we are building for it is impossible to properly identify features of the system as we will have no idea who will be interfacing with our system. Further, without knowing who we are building for we have no idea what goals the system will satisfy, and therefore what requirements we want to implement. This is evermore important as we consider the safety, security, and lifecycle implications of who will be using our system and who will be affected by our system. In the case of the automotive domain, at least two of our stakeholders would be the driver and a pedestrian. Driver as a category however is still quite broad; drivers come in all sorts of different shapes and sizes. Would a young 20 year old male interact with a vehicle the same way a 40 year old female would? What about an 80 year old, healthy male compared to a 30-year-old, overweight male? Or perhaps a 25-year-old female with dwarfism compared to a 25-year-old female with only 1 hand. In all these examples would they all interact with the vehicle the same way? 

When we consider how they may all use a vehicle, their use cases, these will eventually be refined into features. The features identified should allow for the widest range of stakeholders to interface with the vehicle. A unique part of the automotive domain is that all stakeholders identified as a driver are equally pedestrians. Therefore we must consider not only how they will interact with the vehicle, but also how the vehicle will interact with them. Would a blind spot sensor identify only vehicles or also pedestrians. How big does a pedestrian need to be for the front object detection system to recognize it as a person? 

As such there are some clarifying assumptions that we must make as part of our stakeholder identification. These assumptions are made to help with identification and justification of the goals we elicit. Not every domain may require assumptions. This will vary depending on domain and scope of the project. For automotive we can make some of the following simplifying assumptions (as these are assumptions we anticipate the possibility they may change as development continues or new information is gathered):
\begin{itemize}
	\item We assume that drivers are at or above the legal driving age in Canada (16 years old).
	\item We assume that drivers are at or below 80 years old.
	\item We assume that drivers are able bodied enough to legally operate a motor vehicle.
	\item Assume height between 151.895cm and 183.24cm.~\cite{AgeHeightStats} Average range determined between 5th and 95th percentile of male and female population in Canada.
	\item Assume weight between 48.82kg and 106.60kg.~\cite{AgeWeightStats} Average range determined between 5th and 95th percentile of male and female population in Canada.
\end{itemize}

\subsection{Goals}

Once we have identified our stakeholders, we then consider their goals. The goals we identify are highly coupled with how we categorize our stakeholders. 

The goal of a pedestrian is different than that of a driver. For example, a customer who purchases a vehicle is a stakeholder that can be both a driver or a pedestrian (just because they own a car now does not mean they will never walk!). The stakeholder goals will likely be very different based on their current role. However the goals between various stakeholders within a category, such as a 20-year-old male or a one-armed 25-year-old female may be quite similar. As such, identifying the goals of the categories should facilitate eliciting requirements of the stakeholders in each role.

This is where we propose the use of goal diagrams to capture this knowledge and information. Goal diagrams present a unique method of capturing this knowledge as it can be both formal or informal to suit the engineers needs. This flexibility supports the notion of formal picnics explained in Meyer's requirement engineering book~\cite{meyer2022handbook}. The engineer can start informal if needed and can later formalize the model if required to support further analysis. 

According to van Lamsweerde, ``a goal is a prescriptive statement of intent that the system should satisfy through the cooperation of its agents", where an agent can be a human, a device such as sensors or actuators, existing software, or new software~\cite{lamsweerde2009requirements}. Based on our interpretations, we equate these definitions of an agent to our stakeholders of the system so we will carry on referring to them as stakeholders. Thus for a high-level of abstraction at the vehicle-level, we consider the driver, the pedestrian, and the vehicle as agents of our system. As we reduce the scope of our system to smaller portions of a vehicle, to automatic braking, cruise control, or lane-keeping assist, we may consider other sub-systems in the vehicle as our stakeholder and consider what goals those agents may have for the new system boundary.

We propose a syntax which loosely follows the syntax from i* Strategic Rational Diagram~\cite{wautelet2016building, lopez2012specialization}. The legend is shown in figure \ref{fig:legend}. As we are initially using an informal approach we are not as concerned with how the model elements work together or patterns. What we want to convey at this point is what the goals of a stakeholder are, what they might be informed by, and what they might do or use to satisfy those goals. An example goal diagram at the vehicle level can be found in figure \ref{fig:goal_diagram_example}. This goal diagram captures, at a high-level, what the goals of a driver might be when using their vehicle. 

\begin{figure}
	\centering
	\includesvg[width=\textwidth]{Legend}
	\caption{Legend of goal diagram elements.}
	\label{fig:legend}
\end{figure}

\begin{figure}
	\centering
	\includesvg[width=\textwidth]{DriverGoalDiagram}
	\caption{Example goal diagram outlining the goals of a driver using a vehicle.}
	\label{fig:goal_diagram_example}
\end{figure}

Generally, we propose that a driver will use their vehicle to go from one place to another. They are also likely to either carry cargo, people, or both during the commute. They may have some variation in terms of how much cargo or how many people as well. They will also have to drive the vehicle as a task since that is still the main way that people use their vehicle. As part of that task, they will typically want to drive safely to make sure that they get to their destination without issue. While still relatively simple, and without diving very deeply into formally defining the relationship between the model elements we have been able to convey what the goals of a driver could be, introduce some possible variations in goals, and highlight possible goal decompositions. As this is still informal a different engineer may come up with a different goal model for what a driver might do, but they can still be relatively easily merged manually and convey the story of what goals a driver might have as a stakeholder for a vehicle.

As we we will be introducing more formalism later on with the feature modelling and requirement modelling, there is little benefit to introducing that complexity in this stage of development in comparison to the ease of use that we can have with an informal approach to goal modelling. We found a less rigid method of modelling to be more beneficial at this stage to promote wider adoption and understanding for both technical and non-technical individuals. More formalism can always be added by engineers or organizations as needed or desired.

\subsection{Use Cases}

The purpose of the goal diagram is to provide the context of why our identified stakeholders would want to use our system, it does give us answer to what the connections are between our stakeholders and the system. In other words, along with the goals of the stakeholders and our system, we need to identify how the stakeholders will use our system to satisfy their goals. This allows us to capture what the stakeholders will use the system for, supported by the goals of both parties. We may find during this stage that we missed some goals to provide context for some use cases identified. This is also the first opportunity for iteration in the methodology. As we explore the problem space more thoroughly we hope to fill in these gaps as much as possible before we get to the feature modelling and requirement modelling.

\begin{figure}
	\centering
	\includesvg[width=\textwidth]{Driver_UCD}
	\caption{A use case diagram outlining what parts of the vehicle a driver will use.}
	\label{fig:Driver_UCD}
\end{figure} 

In figure \ref{fig:Driver_UCD}, we show the parts of the cabin that a driver is likely to use. It is easier to justify some of the use cases compared to others based on the goal diagram we have already created. For example, the goal of `have fun' is hard to trace to any single use case and can be ambiguous with traceability and justification. Drive safely however can be traced to several use cases, such as brakes, gas pedal, and steering wheel. We can see our goals of `Transport stuff' and `Transport people' are also untraceable to the current \ac{UCD} as we have not specified any use cases around cargo space or passengers. This highlights the first possibility for misalignment between these two modelling efforts; system scoping. The goals of the driver are focused primarily around why they would use a vehicle. When we start to identify use cases there are other questions we want to begin answering. What purpose does the product serve? What problems does it solve for the stakeholder? What do they need to do with our product to solve their problem? The \ac{UCD} has been written with an implied assumption; a driver only interacts with the driver cabin. During its inception it did not consider what other parts of the vehicle might interact with outside of the driver cabin. These kinds of assumptions are typically easy to make and hard to detect. 

As a helpful convention to handle complexity, we consider scoping the system boundary based on the goals from the goal diagram. Thus we can re-title the system boundary from figure \ref{fig:Driver_UCD} to `Vehicle - Drive Vehicle'. This allows a couple of benefits. We can treat each of these \ac{UCD} boundaries as sub-system and having them directly tied to one or many goals from the goal diagram helps with justifying the existence of the newly identified sub-system.

\begin{figure}
	\centering
	\includesvg[width=\textwidth]{Cargo_UCD}
	\caption{\ac{UCD} scoped by the loading cargo goals}
	\label{fig:Cargo_UCD}
\end{figure}

This simple convention also helps with limiting state space explosion with a \ac{UCD} of complex system, such as a vehicle, and also helps with scoping the \ac{UCD} to facilitate system decomposition. We can create another \ac{UCD} to specifically target another goal; 'Transport stuff'. As this effort is not currently tool supported, an external way of maintaining traceability is required. Our initial efforts for this convention have been to maintain a syntactic match or mix between the boundary title and the goal(s) that support its justifications.

For the \ac{UCD} in figure \ref{fig:Cargo_UCD}, we label the boundary `Loading Cargo' as this is the specific portion of the goal that we are focused on; the original goal of `Transport stuff' also has the implication of driving built into it. With this we can separate the \ac{UCD} by goals to identify what use cases will work together to satisfy a goal. This is critical as with this proposed methodology, the identified use cases will be treated as the features of our system. The requirements for the features can therefore also be traced directly to the goals that are used to scope them. 

\section{Features}
\label{sec:features}

After identifying stakeholders, goals, and use cases, we can begin to identify features of the system. Completeness and correctness is not a main focus during initial efforts as we anticipate iteration and incremental changes throughout development. As such we expect that we may learn something new at any step in the process that informs a conscious decision to return to a prior step to improve a previous engineering artifact. 

For this methodology, we want to establish an transformation mapping between use cases and features. Therefore the \ac{UCD} serves two purposes: it identifies what parts of our system a stakeholder will use to satisfy a goal and what features are likely to exist in our system. However, in feature modelling we can have more granularity in how we decompose features compared to in a \ac{UCD}. Usually, this mapping holds true primarily at the higher levels of the feature model. As the feature model is created, further feature decomposition is expected and encouraged further than initial efforts in the \ac{UCD}. As the \ac{UCD} is not considered a static document, iterations between the feature model and the \ac{UCD} are expected. This is especially helpful as there is more granularity in the relationship between features in a feature model compared to use cases in a \ac{UCD}. Generally, the \texttt{inlcude} and \texttt{extend} relationships in \ac{UCD}s are meant to express mandatory and optional use cases respectively according to the SysML specification~\cite{sysml2019omg}. Those are loose definitions however, as the semantics of those relationships are often redefined and toyed with by engineers. Using figure \ref{fig:Cargo_UCD} as an example, regardless of how the drive uses the rear cargo door there must be either a trunk or tailgate; it is mandatory that at least one be present. Conversely, for the backseat use case, given the context of loading cargo into the backseat there must at least be a second row in the vehicle. However, there can be the option of the third row in the vehicle that is not mandatory for the use case to be satisfied, but can still be used based on an arbitrary trigger from the actor.

%This mapping only holds true at the top-level as the \ac{UCD} is not meant to handle use case decomposition beyond the inclusion and extension relationships as is shown in figure \ref{fig:Cargo_UCD}. We refer to the SysML specification~\cite{sysml2019omg} which defines the \texttt{include} relationship to point to the use cases that are mandatory for the source use case to be satisfiable. It is also used to point towards use cases that are shared between multiple source use cases. The \texttt{extend} relationship is used to point toward optional use cases that are not mandatory for the source use case to be satisfiable. The distinction between the two can at time be ambiguous. 

Meanwhile, the relationships in feature models are well-defined and understood. Given the nature of the \ac{UCD} specification there is a lot of information embedded into those relationships that needs to be refined in the transformation from use case to feature. The \texttt{include} relationship can be used to define mandatory features of a system, however, it does not support enough semantics to differentiate between mandatory features that are mutually exclusive. Similarly the \texttt{extend} relationship is not equipped to handle cardinality in optional features where there can be a set of optional feature but a non-empty subset of the optional feature must be selected to complete the product. Thus, while we can equate features and use cases, the relationships between use cases and the relationships between features are less straightforward to equate. We define the relationship between use cases and features as follows:

\begin{gather}
\label{feat-req_hierarchy}
	\text{Let } \mathcal{U} \text{ be the set of all use cases.}\\
	\text{Let } \mathcal{F} \text{ be the set of all features.}\\
	\text{We define } \mathcal{U} \subseteq \mathcal{F} 
\end{gather}

We use the definition above to capture the transformation process from use case to feature. This definition also allows for further feature identification beyond the original scope of the set of use cases used for initialization. This allows for some flexibility as not every new feature identified may need to have an origin use case. This definition captures the injective relationship between use cases and features without forcing it to be bijective.

For a simple system, it may be that no further decomposition of features are required after equating use cases to features. However, for the majority of system development we find that feature decomposition is necessary to create a sufficiently complete feature model and capture all components and configuration possibilities of a system. What the mapping between \ac{UCD}s and features enables is the identification of the initial features of a system. As more feature decomposition occurs, while we encourage iterations between feature models and \ac{UCD}, it is not currently enforced. Hence, we can end up with more features in our feature model compared to use cases in our \ac{UCD}. We can see in figure \ref{fig:FM_init} what a possible initial feature model can look like based on the previous \ac{UCD}s.

%closest to the root of the feature model, the top-most layer. 

\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{FM_init_staggered.png}
	\caption{Initial attempt at a feature model based on use cases identified in \ac{UCD}.}
	\label{fig:FM_init}
\end{figure}

%\begin{figure}
%	\centering
%	\includesvg[width=\textwidth]{FM_init}
%	\caption{Initial attempt at a feature model based on use cases identified in \ac{UCD}.}
%	\label{fig:FM_init}
%\end{figure}

As an informal approach to drawing a feature model we use the black circle notation for mandatory features and the white circle notation for optional features. We have defined the clutch as optional, along with both the rear door features and the back seat features. This is where traditional feature modelling takes over. These are optional features of our vehicle but there hasn't been and compositions relationship defined yet between them, or the other optional features of our system. We can now define conditions around how the various features should be mixed together to create our system, also known as product, as we transition to the world of \ac{PLE}. The various versions of the vehicle that we can create based on figure \ref{fig:FM_init} are known as product variants. These variants are determined based on what optional features we have in a given product.

At a glance, one product variant might be a vehicle with no back seats, a trunk, and a clutch (a typical coupe style vehicle). Another might be a vehicle with one row for a back seat, no clutch, and a tailgate (A truck for example). We can see what these variants might look like in figure \ref{fig:veh_variants}. It shows just the optional features that become mandatory for the new variants. As previously mentioned, there are rules that we can define in order to make sure the product variants are semantically and syntactically valid. For example we could have:
%\begin{gather}
%	\text{vehicle.backseats == null} \implies \text{vehicle.clutch == true}
%\end{gather}

\begin{gather}
	\text{vehicle.backseats == false} \rightarrow \text{vehicle.clutch == true}\\
	\text{vehicle.rearcargodoor.tailgate == true} \rightarrow \text{vehicle.clutch == false}
\end{gather}

Where these conditions state that anytime we have no back seats for a vehicle we must include a clutch pedal in the vehicle or anytime there is a tailgate selected there will be no clutch pedal. This translates to all coupe product variants being manual and all truck product variants being automatic. Naturally, there are requirements for each of these features that we need to capture to support development of these product variants. Since the features are mappings from the use cases, and the use cases are supported by the goals we have outlined, the features are also supported by the goals we have outlined. These next need to be refined to more usable requirement specifications.

\begin{figure}
	\centering
	\includesvg[width=\textwidth]{veh_variants}
	\caption{Product variants for the initial vehicle feature model. Model is simplified to just the optional features that are mandatory for the variant.}
	\label{fig:veh_variants}
\end{figure}

\section{Goal Refinement and User Stories}

The goals from the goal diagram are used to justify the use cases and features because they can be refined to create our requirements. This refinement process takes shape by finding an answer to how the goals are meant to be satisfied and what they are meant to do. Using the goal of `Transport stuff', we rewrite it as a high-level requirement; vehicle shall enable the transportation of items for stakeholder. We ask the next question; how will the vehicle enable the transportation of items? If there is a goal decomposition, we can also correlate the answer to the question of how to a decomposed goals. How will the vehicle enable the transportation of items; the vehicle shall have a large/medium, small cargo space. What is a large/medium/small cargo space? This question is generally up to the engineers and can be decided arbitrarily or justified with research data. 


%For this example we go with an arbitrary decision. Large cargo space shall be in the range of 140-150 cubic feet, medium cargo space shall be in the range of 120-139 cubic feet, small cargo space shall be less than 119 cubic feet.

For writing these user stories we have adapted the use case template from the Meyer requirement handbook~\cite{meyer2022handbook}. The goal outlines what the user wants to happen. The use case indicates what the user can interact with to achieve a goal. The story connects the dots explaining how the user can use the system to achieve their goal.

While these help to provide requirements from the vehicle perspective, they do not help to determine the requirements from the perspective of the stakeholder. For this, we want to decompose our high-level requirements, identified from our goals, into user stories following Meyer's style of requirements. We thus create the following user story around the high-level requirement of the vehicle shall enable the transportation of stuff for the stakeholder:
\begin{itemize}
	\item \textbf{Use Case:} Rear cargo door
	\item \textbf{Actor:} Driver, passenger
	\item \textbf{Trigger:} Stakeholder wants to transport stuff
	\item \textbf{Success Scenario:}
	\begin{enumerate}
		\item Stakeholder identifies access latch to rear cargo area.
		\item Stakeholder uses access latch to open rear cargo door.
		\item Stakeholder is able to lift stuff into rear cargo area.
		\item Stakeholder fits all stuff into rear cargo area.
		\item Stakeholder is able to close rear cargo door.
	\end{enumerate}
	\item \textbf{Secondary Scenarios:}
	\begin{enumerate}
		\item Stakeholder unable to open rear cargo door.
		\item Stakeholder unable to lift stuff into rear cargo area.
		\item Stakeholder unable to fit stuff into rear cargo area.
		\item Stakeholder unable to close rear cargo door.
		\item Stakeholder gets limb or end appendages stuck in door when closing. Door does not close and stakeholder has suffered harm.
	\end{enumerate}
	\item \textbf{Success postcondition:} Stakeholder is safely able to load stuff into rear cargo area.
\end{itemize}

From this user story we can identify many more requirements around the feature of the rear cargo door and we can identify the goal that this story is connected to. The points from the user success scenario become the functional requirements for the feature. The secondary scenario outlines other requirements for the feature, both functional and non-functional. Finally the success post condition highlights the satisfaction of the goal if all requirements are met. In summary, from this user story we can identify the following requirements for the rear cargo door and its sub-features:
\begin{itemize}
	\item Stakeholder shall be able to identify rear cargo door access mechanism.
	\item Stakeholder shall be able to open rear cargo door.
	\item Stakeholder shall be able to shall be able to load rear cargo space with stuff.
	\item Stakeholder shall be able to close rear cargo door.
	\item Door system shall detect object obstructing door closing path. 
	\item Door shall remain open when object is detected obstructing door path.
\end{itemize}

\section{Requirement Modelling and Feature Modelling}

With goals, use cases, high-level requirements, and some refined requirements we can begin modelling our requirements. We refer to this environment as our Requirement Canvas. This environment is heavily inspired by the requirement modelling outlined in the SysML specification ~\cite{sysml2019omg}. We adopted the modelling format and relationsihp between requirements for the requirement canvas. The requirement canvas diverges from its SysML counterpart in its focus on traceability and implementation details. We wanted to allow for a different specification of requirements within the requirement canvas element. We also have different attributes owned by our requirement types in the requirement canvas. The requirement canvas has several main objectives:
\begin{itemize}
%	\item Provide an environment for modelling requirements in a way that emphasizes traceability.
%	\item Provide an environment specifying requirement in more detail after elicitation.
%	\item Provide opportunities for automated maintenance and traceability reports. (This include change impact analysis)
	\item Provide an environment for modelling requirements in a way that emphasizes traceability between features and requirements. This is meant to be a bi-directional relationship to enable traceability in both directions. This is also meant to automatically propagate changes in both directions.
	\item Provide users with the ability to specify requirement behaviour in greater detail with a specification language. The language of choice we use at this time is the Gherkin specification language~\cite{cucumberdocs}.
	\item Support categorizing requirements. Instead of just having a generic requirement, we want to ability to specify early on whether a requirement is functional or non-functional. We further categorize the non-functional requirements into more specialized categories.
\end{itemize}  

With these in mind, a metamodel was created to provide a specification for how to create models in our newly identified requirement canvas. The metamodel for the requirement canvas is shown in figures \ref{fig:req_canvas_mm1} and \ref{fig:req_canvas_mm2}. This metamodel has also been used to develop a domain-specific modelling language named \tool. With \tool, we aimed to show feasibility of the proposed methodology. This includes the overall objectives of supporting iterative and incremental development and partially automated traceability generation and maintenance.

%capture these objectives and provide a specification for how to model our requirements 

The requirement canvas portion of the metamodel was created after several iterations of identifying what elements are needed to facilitate the three main objectives for the modelling environment. An important distinction that separates this specification from the requirement model specification for SysML is the requirement types that we have defined. For the requirements in the requirement canvas, we identified four requirement categories; \texttt{Functional}, \texttt{Qualitative}, \texttt{Constraint}, and \texttt{Safety}. Functional requirements follow their traditional definition; things that a product or system must do. Qualitative requirements are identified as requirements that affect the way a product or system accomplishes its function. These include the look, feel, usability, humanity, and some performance requirements that are not categorized as functional. Constraint requirements are identified as requirements that add limitations of some type to a product or system. These include operational, environmental, maintainability, support, security, cultural, political, and legal requirements. These requirement definitions can be found in James and Suzanne Robertson Volere requirements~\cite{robertson2000volere}. Finally, safety requirements are critical as they identify all requirements that have to do with the safety of users or stakeholders involved in the function of a product or system. We highlight safety requirements as a separate requirement category as our target domain for \tool\ is safety-critical development. This also gives us flexibility to change the profile of the safety requirement type to match safety integrity level ratings based on target domain.

%\begin{figure}
%	\centering
%	\includegraphics[width=\textwidth]{rmdl.pdf}
%	\caption{CyclicL metamodel. Shows the specification for both the requirment canvas and feature modelling portions of CyclicL.}
%	\label{fig:metamodel}
%\end{figure}
%
%\begin{figure}
%	\centering
%	\includegraphics[width=\textwidth]{metamodel.pdf}
%	\caption{CyclicL metamodel. Shows the specification for both the requirement canvas and feature modelling portions of CyclicL.}
%	\label{fig:metamodel}
%\end{figure}
\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{feature_mm.png}
	\caption{CyclicL metamodel. Shows the specification for the feature modelling portion of CyclicL.}
	\label{fig:feature_mm}
\end{figure}
\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{req_canvas_mm1.png}
	\caption{CyclicL metamodel. Shows the specification for the first half of the requirement canvas portion of CyclicL.}
	\label{fig:req_canvas_mm1}
\end{figure}
\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{req_canvas_mm2.png}
	\caption{CyclicL metamodel. Shows the specification for the second half of the requirement canvas portion of CyclicL.}
	\label{fig:req_canvas_mm2}
\end{figure}
\begin{figure}
\centering
\includegraphics[width=\textwidth]{mm_root.png}
\caption{CyclicL metamodel. Shows the specification relationship between the requirement canvas and feature modelling portions of the metamodel. Also shows their relation to the model root.}
\label{fig:mm_root}
\end{figure}

We also added three more classes besides the requirements; \texttt{DesignElement}, \texttt{Review}, and \texttt{TestCase}. The test case and review classes are for verification and validation book-keeping respectively. This is also one of the reasons why we include design elements within the requirement canvas. The test cases are meant to determine if a requirement has been verified against its traced design elements while the review represents if the requirement has been validated. Currently, the verification and validation are expected to happen outside of \tool\ as it was out of scope for initial development. We have an enum \texttt{TestType} tied to the test cases. This enum will eventually allow users to categorize the test they may want to apply to their requirements. At this time in development, only \texttt{UnitTest} is implemented as a type, but more can be added in future revisions.

The \texttt{DesignElement} is perhaps a more controversial addition. There is a risk of polluting the requirements by adding design elements this early in development. The main reason we add them in the metamodel at this stage is once again to enable traceability. Design elements in the requirement canvas are meant to be black boxes to mitigate this potential issue. We have limited the class to determining if a design element is hardware, software, or neither (undetermined when building the requirements or an integrated system). Another reason for having design elements within the requirement canvas is to allow an potential path for future development, specifically design generation based on the requirements specified in \tool.

For the feature modelling portion of the metamodel shonw in figure \ref{fig:feature_mm}, we tried to remain in-line conceptually with previous work~\cite{kang1990feature,kang1998form,kang2002feature}. The \texttt{Feature\_Model} element is the container for the feature model which is composed of \texttt{FeatureEntity} type elements. There is the \texttt{Root} element which will form the actual root of the feature model. This is limited to a single \texttt{Root} element per model. The root of the model then decomposes to the \texttt{Element} type via the three relational associations: \texttt{Alternative}, \texttt{Mandatory}, and \texttt{Optional}. These three relationships are once again bi-directional to enable traceability in either direction throughout the feature model. 

Finally, we have the \texttt{Product\_Variant} type class defined as an inherited type of \texttt{Feature\_Model}. This is what allows for users to define their product variants at the highest level and have all the same semantic capabilities as the regular feature model while still allowing us to define more specific semantics around the product variants, such as allowing us to have a zero-to-many multiplicity on how many product variants we can have per feature model.

This specification is loosely based on the work of Peter H\"{o}fner et al.~\cite{hofner2006feature,hofner2011algebra} which uses set theory as the basis for proving how their feature modelling algebra works. It is also loosely inspired by FeatureIDE~\cite{kastner2009featureide, thum2014featureide} a feature modelling plugin tool for Eclipse. The main reason we recreated the specification for feature modelling within \tool\ is to explore the implication of using features to encapsulate requirements, shown in figure~\ref{fig:mm_root}. This is a key step in the process as this allows for what we dub feature-requirement traceability. As this proposed methodology suggests that features be used to encapsulate requirement to support feature-driven development efforts, having a way of representing that relationship in a formal specification such as a metamodel was impactful both for the development of \tool\ and the development of the concept.

The complete metamodel can be found in appendix~\ref{apdx:CyclicL_mm}.

\section{Feature-Requirement Traceability}
\label{sec:feat-req_traceability}

Feature-requirement traceability is a main contribution of this thesis. As previous steps have been taken to identify both the features and requirements of the system, this relationship between features and requirements is integral for the process. This relationship is captured by the inheritance connection between the \texttt{Requirement\_Canvas} and the \texttt{FeatureEntity} classes in the metamodel. By allowing every model element in the feature model to double as a requirement canvas, it allows each feature to contain all the modelled requirements in the requirement canvas. Thus, the individual features are encapsulating the various types of requirements, their associated approvals, and their associated design elements. 

The decision to implement the encapsulation as we did was heavily influenced by the desire to tie together two separate modelling approaches and maintain traceability between both modelling environments. This relationship as we have specified allows for several key benefits. First, it provides a mechanism for direct traceability between the requirements and their respective features. Since every requirement will be `owned' by a feature, we can easily trace the relationship between requirements within a feature, between various features, and within the entire system. Secondly, this modelling approach creates minimizes the amount of connections needed between the two modelling environments to a single inheritance relationship while still supporting all our traceability objectives. Thirdly, this allows us to model product variance at the requirement level. Specification of product variance has the potential to be helpful for reducing unexpected changes and capturing knowledge of anticipated variance early in the product lifecycle development. Further, this can be used to support change impact analysis across product variants and their specifications to facilitate product maintenance. 


%Using a metamodel to specify this relationship allowed to to specify a tool at the same time thanks to \ac{EMF} and Sirius in Eclipse. It satisfies the hierarchy we outlined in Section \ref{sec:features} on line \ref{feat-req_hierarchy}.



Some anticipated downsides to this extension is that it might not be compatible with existing feature model composition approaches. Since every feature element now doubles as a requirement canvas this can break conventional feature composition strategies forcing us to create new ones. Another downside is handling requirements that can be related to multiple features. Due to the encapsulation strategy we are proposing, \tool\ does not support cross-cutting requirements across features at this time. There might be ways that users circumvent this which can lead to duplicated or inconsistent requirement across several features. 

\begin{figure}
	\centering
	\includesvg[width=\textwidth]{feature-requirement}
	\caption{Example of how a feature can be opened up to display encapsulated requirements.}
	\label{fig:feature-requirement}
\end{figure}

In figure \ref{fig:feature-requirement} we show the intention of having the features encapsulate the requirements. There is an explicit method for information hiding, and access to the requirements necessitates diving into a feature. This is where we transition from feature modelling to the requirement canvas. Within the canvas we can then define our requirements and specifications for the owning feature. 

\section{Requirement Specification}

Between the goal diagrams and use case diagrams we showed how we can carry out requirement refinement via user stories. In the requirement canvas we intend to express these requirements as a behavioural specification. This is beyond just refinement however, as part of the requirement canvas we also enable requirement specification. Currently we support behavioural specification through an interpreted implementation of Gherkin syntax~\cite{cucumberdocs}. The Gherkin style of specification is a structured natural language approach to specifying behaviours. It follows a pseudo predicate logic system using three main keywords; GIVEN, WHEN, and THEN. The GIVEN keyword is used to express behavioural preconditions. The WHEN keyword is used to express events that trigger some new behaviour. These triggers can be either internal or external to the specified system. Finally, the THEN keyword is meant to specify behavioural postconditions. 

The reasons for using Gherkin style specifications in the requirement canvas is two-fold. We want to specification environment to be both easy to use and read. This provides a low barrier for entry to specify requirements and reading them. This increased flexibility is meant to both technical and non-technical people to specify system requirements. Secondly, while the flexibility is good, we still wanted some constraints for how specifications can be written. Rather than introducing some arbitrary constraints ourselves, Gherkin provided a nice off the shelf solution. Despite our current implementation not being completely faithful to the original specification, it is enough for a proof of concept.

\section{Requirement Based Feature Identification}

Due to the relationship between features and requirements assumed and defined in this methodology there are alternative ways to identify features. The variation points that exist in this approach are the requirements held in the features. As a result, variant requirements can potentially identify new features previously missed by the \ac{UCD}. Thus far this methodology has been primarily top-down in the approach to identifying features using the domain analysis. However, it is expected that variant requirements will be identified during the elicitation process. This introduces the possibility for a bottom-up approach to identify features. Variant requirements elicited should still be supported by the goal diagram. Naturally, through this bottom-up portion of the methodology, it is encouraged to iterate on previous steps as engineers incrementally follow the approach.

\begin{figure}
	\centering
	\includesvg[width=\textwidth]{acc_fm}
	\caption{Simplified example of an adaptive cruise control feature model.}
	\label{fig:acc_fm}
\end{figure}

In figure~\ref{fig:acc_fm}, we can see a simplified feature model of an Adaptive Cruise Control (ACC) system. For the auto braking feature there are two alternative features available underneath denoted with the aggregation symbol at the source and open circle at the target. Sensor fusion requirements based on possible variant products (such as radar and camera versus lidar and sonar implementations) generate alternative features under the auto braking feature. Any requirements that can apply to both are expected to be abstracted up a feature to auto braking. This scoping is meant to reduce cross cutting concerns between features due to requirement dependencies.

In summary, the proposed methodology provides a process to combine \ac{MDE} and \ac{PLE} for the purpose of improving requirement elicitation, requirement specification, feature identification, and product planning. It also provided a metamodel to specify a language that can show the feasibility of the process and potential for supporting automated traceability documentation generation and maintenance throughout a product's lifecycle. 

Next we will show a tool implementation of \tool\ fo the purpose of showing feasibility of the language and potential tool support for the methodology.




