\chapter{Introduction}

What came first, the chicken or the egg? It is a silly question that people will often debate about over dinner or on the bus. In engineering there is a similar debate; what comes first, the feature or the requirement? Very often when we do engineering work we consider what we want to build in parallel to actually thinking about building it; exploring the problem space often gets overlooked in favor of exploring the solution space. As a result, an engineer may have to backtrack to their requirements when they hit a wall during development. They may find that their requirements were incomplete for their feature. Perhaps the scope of their feature is much bigger than they anticipated; maybe what was originally considered to be a single feature could in fact be multiple features. Thus, the engineer will iterate back and forth between features development and requirement development, incrementally changing each until they get to a system state that they consider to be complete, or at the very least a minimum viable product. 

How do we capture this process? \ac{FDD} is a common practice for agile development styles whereby the engineers will identify a set of features that will be built together to create a system. They will then work to identify acceptance criteria, or descriptions of each feature to specify what needs to be done for each feature and how to know when it is complete. These descriptions end up behaving very similarly to requirements for the features, if not outright being written as requirements for the feature. Therefore, we can make the proposition that before we have requirements, we have features. The features come first, thus we should focus on identifying features before we start to think about what requirements we need for a given system.

There is a major assumption made in this scenario; are there not already existing requirements before we begin to identify features? For more mature development teams and industries, it is very rare to start from scratch without any requirements, and even more rare to jump right into identifying solutions without first having an idea of what the problems are. Thus, even if limited, there are at least some guiding requirements before engineers begin to identify features of their system that will solve their problems. Therefore, we say that requirement come before the features. 

In reality, both scenarios are likely to happen, perhaps even within the same company. We may find that we have a vague idea of what the problem is, perhaps even some simple drafts of the problems and what requirements we may have to solve them. However, it is common that we know what we want to build before we specify anything of the system as we already have some domain knowledge and can predict what problems we will solve with a given solution. Thus we begin to identify features of our solution and later will go to specify our system what requirements apply to our given features.

This generates a couple of problems for development. The relationship between requirements and features becomes somewhat ambiguous. In fact, what are the differentiating factors between a feature and requirement? For this thesis, we will follow the definition of a feature from the original work of Kyo Kuang et al.~\cite{kang1990feature, kang1998form} for their Feature-Oriented Domain Analysis \ac{FODA} and Feature-Oriented Reuse Method \ac{FORM}. According to their original definition, a feature is "a prominent or distinctive user-visible aspect, quality, or characteristic of a software system or systems." Based on how we interpret this definition, we could consider that any portion of a system that a user can interface with is viable to become a feature. In fact for the sake of inclusion, we extend this definition to not only be user-visible, but simply user-interface-able, taking into account the multiple different senses that a user can use to interact with our system. This will increase the scope of a feature beyond what is only visible, including sound, touch, smell, and taste. 

What is a requirement? This is well developed and studied topic. To answer, we look to Axel van Lamsweerde~\cite{lamsweerde2009requirements} where he outlines the purpose of requirements engineering is to answer three question; what, why, and who? What is the problem we are trying to solve? Why is it worth solving? Who should be involved in the solution? There are many more requirements engineering approaches and strategies that we can and will use to develop our methodology, however as a base line when understanding what a requirement is it should answer what the problem is that we are solving supported by sound reasoning for why it is worth being solved and who is involved in solving the problem. 

As such, what are the problems we are trying to solve with this thesis? For one, what is the relationship between features and requirements? This is a problem due to ambiguous relationship between them and the different development styles that exist. As there are dependencies between them, setting a definition of the relationship between them may help with both making sure that we elicit and refine requirements that are correct and reasonably complete. At the same time, it can help to ensure that the features we identify are correct and reasonably complete.

Another issue is that iterations between features and requirements do not happen in isolation. There is usually a lot of supporting documentation and software that surrounds and depends on both the requirements and identified features. This is usually expressed through traceability documentation, most commonly in a traceability matrix. However, maintaining a traceability matrix with all the incremental changes that happen between requirements and features is an extremely tedious and time consuming task. For each change it is usually a low return for high effort task, until such a time that the traceability matrix is so out of sync with both the requirements and features that is it no longer usable. Which means we create a whole new traceability matrix and thus the cycle continues. Therefore, traceability documentation is a very large problem during iterative and incremental development.

%\ac{FDD} as a development style misses a very key component. How do all the features fit together? This is a problem that is addressed by Product Line Engineering \ac{PLE}. 

We also examine implication for agile development styles. \ac{FDD} is a feature focused development methodology that already has some set rules for implementation. We also want to explore some possibilities that may exist for adoption into existing development approaches. The objective here would be to explore methods for improvement rather than redefining entirely how \ac{FDD} might be implemented, especially tying it in with \ac{MDE} and \ac{PLE} efforts. This is true both at the conceptual level and the tool support level.

Originally conceptualized by Kyo Kuang et al.~\cite{kang1990feature, kang1998form}, it has since evolved into a highly researched topic with supporting tools like FeatureIDE~\cite{kastner2009featureide, thum2014featureide} which supports feature composition of software artifacts. Or a tool like GEARS~\cite{GEARS} which emphasizes its 3-tiered software product line methodology. There is also formal methods research for \ac{PLE} such as the work of Peter H\"{o}fner et al.~\cite{hofner2006feature,hofner2011algebra}, which created a formal algebra for how to compute product lines and feature models. What these tools lack however is an self-contained way to manage traceability between features and requirements; FeatureIDE focuses on code composition where GEARS requires hooking into separate requirements engineering tools and does not have a way to handle requirements independently. Thus we identify a lack of tool support for traceability and iterations between requirements and features as another problem.

Finally, the problem of how we accomplish all of these tasks? What is the methodology to help make sure the features we identify are correct and sufficiently complete? What is the methodology to make sure that we identify requirements that are correct and sufficiently complete? How can we be sure that our mappings between requirements and features also make sense? This is another problem as we want to make sure that the mappings between features and requirements are correct and complete for development tasks as much as for assurance purposes. We want developers to be developing the correct features, and we want to be capable of reasoning about those features so that we can develop assurance that properties of our system are true. This is the final we have identified.

A confounding variable in all of these problems that we have not yet identified \ac{PLE} is usually a \ac{MDE} process

It is important to note that while not mandatory, many \ac{PLE} efforts also use modelling in their approach. There is a lot of cross-pollination that already exists between the two domains. For our purposes, we want to examine these problems through the lens of \ac{MDE} primarily; can we solve these problems using \ac{MDE} techniques and processes? We support \ac{PLE} through \ac{MDE} techniques and methodologies rather than using modelling as a means to an end.

In summary, these problems culminate into the following research questions:
\begin{enumerate}[label=\textbf{RQ.\arabic*}]
%	\item[RQ1: ]\label{RQ:1} How can we improve requirement elicitation and feature identification processes in \ac{FDD}?
%	\item[RQ2: ]\label{RQ:2} How can we improve traceability maintenance between features and requirements?
%	\item[RQ3: ]\label{RQ:3} How can we improve tool support for iterative and incremental development between features and requirements?
%	\item[RQ4: ]\label{RQ:4} How can we leverage \ac{MDE} techniques for domain analysis, problem space exploration, and requirement
	\item \label{RQ1} How can we improve the state of implementation and usability of \ac{FDD}?
	\item \label{RQ2} How can we improve the maintenance and generation of traceability between features and requirements?
	\item \label{RQ3} How can we improve tool support for iterative and incremental development between features and requirements?
	\item \label{RQ4} How can we leverage \ac{MDE} techniques for domain analysis, problem space exploration, and requirement development?
\end{enumerate}


\section{Motivation}

In many industries, we can find companies that have a catalog of products they offer to customers. There are also many industries that focus on safety-critical application development. Some areas where these two categories overlap are the automotive domain and the medical device domain. Within automotive industry, companies offer a range of vehicles customers can choose for purchase. Further, each of the vehicle models on offer can have variants available. These vehicle model variations can be due to aesthetic difference or functional differences. There can also be variations due to where in the world the vehicle is being sold, such as the driver seat location depending on if the country of sale drives on the left or right side of the road. 

Further, vehicles are inherently dangerous products to be sold. According to the Canadian government, there were a total of 91533 vehicle collisions reported in 2022, resulting in 1931 total fatalities~\cite{CanadaCrashStats}. It is beyond reasonable doubt that automotive development can be considered a safety-critical industry as well to improve the safety of vehicles to reduce accidents, fatalities, and injuries. Thus, we can see that the automotive industry is one that requirement \ac{PLE} to help with managing the product catalog, requires help with managing documentation to develop safety cases (or assurance cases in general), and help with iterative and incremental development as they release new vehicles year after year.

For medical device development, product variant also exist as companies may be required to fine tune or adapt a product to different country regulations. Another point of variation can come from the intended use case of a medical device. The same device may be used to treat different diseases or ailments under different conditions and enabling or disabling this kind of functionality can be critical for regulatory approval. It can also be part of the discovery process as a new application for existing technology can be discovered. This event occurs all the time in the medicine and medical technologies. The ability to plan out new product variants can be extremely beneficial for product planning and development

Throughout this thesis we will be using examples from the automotive domain. These examples will aim to help provide context for the work and aid in the evaluation of the methodology and tooling. Then we use an example pacemaker project in the evaluation section of this thesis to examine the proposed methodology side by side with an existing requirement document for a medical device.

\section{Hypothesis}

With the research questions defined and the motivation outlined, we can start to take some guesses at how to answer them. Beginning with \ref{RQ4}, there are several modelling techniques to use. For the domain analysis and identification of system features, we propose the use of \ac{UCD} from SysML~\cite{sysml2019omg}. As a modelling technique it is quite informal, however it is also easy to use for analysis and problem space exploration. The biggest reason to use \ac{UCD}s is the requirement to identify actors/stakeholders of the system and how they might use the system. The idea of a use case is very similar to what a feature of a system is and thus allows for a relatively easy mapping between system use cases and features.

Another \ac{MDE} technique we use for domain analysis and problem space exploration is Goal Diagrams as outlined in Axel Van Lamsweerde's requirements engineering textbook~\cite{lamsweerde2009requirements}. Lamsweerde has formal semantics defined for goal diagrams which helps with making sure that we can properly reason about the goals of the system, as well as the goals of the users. However, in spite of the formal semantics Lamsweerde has prescribed to goal diagrams, there are variant syntaxes that exist for goal diagrams that do not strictly adhere to the syntax and thus the semantics that Lamsweerde has defined. This has pros and cons. As a benefit, the reduction of formality can lower the barrier for entry, thus making it easier to use across professions as back of the envelope forms of expression. The loss of semantics however makes it more difficult to use as a method of reasoning around goals and the possible requirements they can be used to derive. This flexibility does help overall however with the usability of goal diagrams and their use for exploring the problem space to elicit requirements.

The reason we chose these two \ac{MDE} techniques is part of the answer to Rref{RQ1}. For the rest, we turn to the Handbook of Requirements and Business Analysis by Bertrand Meyer~\cite{meyer2022handbook}. In his book, Meyer outlines several steps towards the requirement elicitation process, which also apply themselves well to feature identification. Parts of his book outline the importance of identifying goals of both the system and the users, along with identifying the importance of user stories and use cases. Further, he supports the use of both formal and informal methods, leaving it up to the engineer to decide when it is necessary to use one over the other based on context. We support that notion, and much of the methodology we outline is inspired from his book. The \ac{UCD}s created for analysis will also be used to outline user stories to refine and justify the identified features. The goal diagrams from Lamsweerde's requirements engineering are used to support the goals book from Meyer in either a formal or informal capacity based on the engineer's discretion.

For \ref{RQ2}, we propose the following hierarchy; features shall encapsulate requirements. The reason for this proposal is two-fold. For one, there are many more semantics around feature modelling and \ac{PLE} compared to requirement modelling. And for the second point, in \ac{FDD} we often list requirements as scoped by a feature. As many engineers and developers are familiar with this type of development we felt it would be easier for them to adapt to this type of relationship as opposed to the other way around. By having features encapsulate requirements, we can get feature-scope requirement traceability as every requirement will be owned by a feature. We will hence forth refer to this as feature-requirement traceability.

This also helps with \ref{RQ3} as the encapsulation will help with supporting traceability. By formalizing the relationship between features and requirements, tool development becomes simplified as we can leverage existing Object-Oriented techniques to develop a \ac{DSL} to support iterative and incremental development of both features and requirements. We can leverage a tool that is self-contained to attempt to partially automate traceability maintenance when making changes to either features or requirements in either a feature model or requirement model.

In summary, the hypothesis is that we propose that we let features encapsulate requirements for supporting traceability. Leveraging this definition we can build a tool that supports partial automation of feature-requirement traceability. We can use existing \ac{MDE} techniques in \ac{UCD}s and goal diagram for domain and problem space analysis inspired by Bertrand Meyer's style of requirements engineering.




